Arrays:
  - Semantic analysis for negative sizes (Static) on constant ints
  - LLVM
    -- Reference in functions and assignments


TODO:
GROUP2:
  -- Short circuiting (DISTRIB)
  -- Problem with return (multiple returns in the same block are not allowed, however
      every basic block must have a terminating statement- theoritika einai ok)
GROUP3:
  -- seira metavlhtwn sto call (?)
  -- By Ref parameter passing
  -- Outer Scope parameter passing
  -- Check Garbage Collector (for-lists.tony)

------------

10001101
->
SExt/ZExt (i64)
->
0000000000000000000000000000000000000000000010001101
->
10001101

a ||( b || c)
--  --------
_true = Builder.Create.Icmpq(....)
_false = .....
Phi res
if a
Phi res


def program():
  int b
  def fun():
    def fun2():
      int a
      a := 42
    a := 2
    exit
  end
  int a
  a := 3
  fun()
end


def program():
  int a
  def fun(ref int a):
    def fun2(ref int b):
      b := b + 1
    end
    a := a + 1
    fun2(a)
  end
  a := 1
  fun(a)
  puti(a) % Should print 3
  putc('\n')
end

call(a, b)
!realLeft -> Load(alloainst)

varlist: mallon swsta
header's arglist: anapoda alla eswterika me swsth diata3h ()

wrong testcases:
  by-ref (instruciton does not dominate all uses)
  lists3 (seg fault, see line 21)
  shadow (instruciton does not dominate all uses)
  simple-if5 (instruciton does not dominate all uses)
  simple-nest2 (instruciton does not dominate all uses)

proposed and implemented solution is marking block as uncreachable.
That solves the non terminating block problem, at least as far as I can see.
