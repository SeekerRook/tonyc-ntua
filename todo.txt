Arrays:
  - Semantic analysis for negative sizes (Static) on constant ints
  - LLVM
    -- Reference in functions and assignments


TODO:
GROUP2:
  -- Short circuiting (DISTRIB)
  -- Problem with return (multiple returns in the same block are not allowed, however
      every basic block must have a terminating statement- theoritika einai ok)
GROUP3:
  -- Outer Scope parameter passing
  -- Check Garbage Collector (funny behaviour when malloc is the only statement, maybe llvm IM generation pre-optimizes)

------------

10001101
->
SExt/ZExt (i64)
->
0000000000000000000000000000000000000000000010001101
->
10001101

a ||( b || c)
--  --------
_true = Builder.Create.Icmpq(....)
_false = .....
Phi res
if a
Phi res


call(a, b)
!realLeft -> Load(alloainst)

wrong testcases:
  by-ref (instruciton does not dominate all uses)
  shadow (instruciton does not dominate all uses)
  simple-if5 (instruciton does not dominate all uses)
  simple-nest2 (instruciton does not dominate all uses)

proposed and implemented solution is marking block as uncreachable.
That solves the non terminating block problem, at least as far as I can see.


int a
# live : a
def fun (int b):
  return a + b
-> fun(int b; ref int a)
u.eFunction.outer_parameters_list
call



def program ():
  int a,b
  def piofun (int a, b):
    int c
    def fun (int a, b):
      if a < 0:
        if b > 0:
          c := 2
        end
      elsif a > 0:
        if b < 0:
          c :=3
        end
      end
    end
  end
  a := 1
  b := 2
  piofun(a, b)
end




initSymbolTable();
blablabla
we get the set -> setHeaderLive
destroySymbolTable();
initSymbolTable();


we need std::vector<pair<const char *, Type>> live_vars
