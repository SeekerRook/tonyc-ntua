Arrays:
  - Semantic analysis for negative sizes (Static) on constant ints
  - LLVM
    -- Reference in functions and assignments


TODO:
  -- Outer Scope parameter passing


------------

10001101
->
SExt/ZExt (i64)
->
0000000000000000000000000000000000000000000010001101
->
10001101

a ||( b || c)
--  --------
_true = Builder.Create.Icmpq(....)
_false = .....
Phi res
if a
Phi res


call(a, b)
!realLeft -> Load(alloainst)

wrong testcases:
  by-ref (instruciton does not dominate all uses)
  shadow (instruciton does not dominate all uses)
  simple-if5 (instruciton does not dominate all uses)
  simple-nest2 (instruciton does not dominate all uses)

proposed and implemented solution is marking block as uncreachable.
That solves the non terminating block problem, at least as far as I can see.


int a
# live : a
def fun (int b):
  return a + b
-> fun(int b; ref int a)
u.eFunction.outer_parameters_list
call



def program ():
  int a,b
  def piofun (int a, b):
    int c
    def fun (int a, b):
      if a < 0:
        if b > 0:
          c := 2
        end
      elsif a > 0:
        if b < 0:
          c :=3
        end
      end
    end
  end
  a := 1
  b := 2
  piofun(a, b)
end


1) Fix the allocainst of Activation Record.
2) One function to find the correct Activation Record.
!!! We have to check if ID if parameter, this will be done with lookupEntry
parameters are allocated in the current stack frame whereas variables are
allocated in the stack frame.
3) Use GEP with appropriate offsets to get a ptr to the variable address.
4) Create the appropriate load/store. (see class id for the appropriate options)
5) Pass PTR to parent frame as parameter in every nested function. This should happen
in function ir codegen and in call codegen.
